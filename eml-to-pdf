#!/usr/bin/env python3

import argparse
import sys
import tempfile
from datetime import datetime
from email import policy
from email.message import EmailMessage, MIMEPart
from email.parser import BytesParser
from email.utils import parsedate_to_datetime
from pathlib import Path
from typing import NamedTuple
from zoneinfo import ZoneInfo

import weasyprint as wp
from bs4 import BeautifulSoup
from jinja2 import Environment
from pypdf import PdfReader, PdfWriter

EML_CONTENT_TYPES = ('text/html', 'text/plain')
EML_HEADERS = ('Date', 'Subject', 'From', 'To', 'Cc')
TS_FORMAT = '%-d %B %Y, %H:%M (%Z)'  # https://strftime.org/
TZ = ZoneInfo('Europe/London')

# Internal
BASE_DIR = Path(__file__).resolve().parent
CSS_FILE = BASE_DIR / 'style.css'

HTML_TPL = """<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>EMAIL: {{ headers.Date | date_fmt }} - {{ headers.Subject | escape }} - {{ headers.From | escape }}</title>
    <meta name="author" content="{{ headers.From | escape }}">
    <meta name="dcterms.created" content="{{ headers.Date | replace(' ', 'T') }}">
    <link rel="stylesheet" href="{{ CSS_URI }}">
</head>
<body>
<div id="headers">
    <table>
    <tbody>
        {% for key, value in headers.items() %}
        {% if value is not none %}
            <tr>
                <th>{{ key }}:</th>
                <td>{{ value | date_fmt | escape }}</td>
            </tr>
        {% endif %}
        {% endfor %}
    </tbody>
    </table>
</div>
<div id="content" class="{{ mimetype | replace('/', '-') }}">
{{ content | safe }}
</div>
</body>
</html>
"""


class ParsedPart(NamedTuple):
    content_type: str
    payload: str


def date_fmt(value, date_format=TS_FORMAT):
    if isinstance(value, datetime):
        return value.strftime(date_format)
    return value


def strip_html_tags(html_source: str) -> str:
    soup = BeautifulSoup(html_source, 'html.parser')
    # Delete all <style> tags
    for tag in soup.find_all('style'):
        # print('Removing tag:', tag, file=sys.stderr)
        tag.decompose()
    # Delete all style= attributes
    for tag in soup.find_all(style=True):
        del tag['style']
    if soup.body:
        return ''.join(map(str, soup.body.contents))
    return ''


def read_eml(eml_path: str) -> EmailMessage:
    # Load the email
    fb = Path(eml_path).read_bytes()
    msg = BytesParser(policy=policy.default).parsebytes(fb)
    return msg


def parse_single_header(msg: EmailMessage, head: str):
    '''
    Parse a single msg header at a time.
    '''
    if head == 'Date':
        return parsedate_to_datetime(msg[head]).astimezone(TZ)
    return msg.get(head)


def parse_all_headers(msg: EmailMessage):
    header_values = [parse_single_header(msg, h) for h in EML_HEADERS]
    return dict(zip(EML_HEADERS, header_values))


def parse_part(part: MIMEPart) -> ParsedPart | None:
    if part.is_attachment():
        return
    content_type = part.get_content_type()
    if content_type in EML_CONTENT_TYPES:
        print(content_type, file=sys.stderr)
        charset = part.get_content_charset() or 'utf-8'
        payload = part.get_payload(decode=True).decode(charset, 'ignore')
        if content_type == 'text/html':
            payload = strip_html_tags(payload)
        return ParsedPart(content_type, payload)


def parse_multipart(msg: EmailMessage) -> ParsedPart:
    # Flat list of all sub-parts
    parsed_parts = (parse_part(part) for part in msg.walk())
    all_parts = list(filter(None, parsed_parts))
    # Will sort text/html before text/plain
    all_parts.sort()
    print(f"Parts found: {[p.content_type for p in all_parts]}", file=sys.stderr)
    return all_parts[0]


def eml_to_html(msg: EmailMessage):
    # Extract headers
    headers = parse_all_headers(msg)
    mimetype, content = parse_multipart(msg)
    env = Environment()
    env.filters['date_fmt'] = date_fmt
    template = env.from_string(HTML_TPL)
    return template.render(
        CSS_URI=CSS_FILE.as_uri(),
        headers=headers,
        mimetype=mimetype,
        content=content,
    )


def save_html(path, html_content):
    with tempfile.NamedTemporaryFile(
        delete=False, prefix='eml-', suffix='.html', mode='w', encoding='utf-8'
    ) as tmp:
        tmp.write(html_content)
    print(tmp.name, file=sys.stderr)


def save_pdf(path, html_content, pages=1):
    eml_path = Path(path)
    pdf_dir = eml_path.resolve().parent / 'pdf_print'
    pdf_dir.mkdir(exist_ok=True)
    pdf_path = pdf_dir / (eml_path.stem + '.pdf')
    wp.HTML(string=html_content, base_url=str(BASE_DIR)).write_pdf(pdf_path)
    keep_pages = pages if (pages and pages > 0) else 1
    reader = PdfReader(pdf_path)
    total_pages = len(reader.pages)
    if not total_pages:
        raise RuntimeError('No pages generated for PDF')
    if keep_pages < total_pages:
        # Trim to the requested number of pages while retaining metadata
        print(
            f'Found {total_pages} pages in total, but keeping {keep_pages} pages',
            file=sys.stderr,
        )
        writer = PdfWriter()
        for idx in range(min(keep_pages, total_pages)):
            writer.add_page(reader.pages[idx])
        if reader.metadata:
            writer.add_metadata(reader.metadata)
        with pdf_path.open('wb') as pdf_file:
            writer.write(pdf_file)
    print(f'"{pdf_path}"')


if __name__ == '__main__':
    if not CSS_FILE.is_file():
        raise RuntimeError('Could not find CSS File')
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-p',
        '--pages',
        type=int,
        default=1,
        help='Number of pages to keep (default: 1)',
    )
    parser.add_argument('email_files', type=str, nargs='+')
    args = parser.parse_args()
    # Run all
    for eml_path in args.email_files:
        raw_eml = read_eml(eml_path)
        html_content = eml_to_html(raw_eml)
        save_html(eml_path, html_content)
        save_pdf(eml_path, html_content, pages=args.pages)
